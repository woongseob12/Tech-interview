# OS

## 프로세스란?

`실행 중인 프로그램(= 스케줄링의 대상이 되는 작업)`
`운영체제로부터 자원을 할당받는 작업의 단위`

- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- OS로 부터 시스템 자원을 할당받는 작업의 단위
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 됨. 이 순간부터 **프로세스**라고 부름.

- 할당받는 시스템 자원

  - CPU 시간
  - 운영되기 위해 필요한 주소 공간
  - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

- 메모리 구조

  - Code 영역: 프로그램을 실행시키는 실행 파일 내의 명령어 할당
  - Data 영역: 전역변수, static 변수 할당
  - Heap 영역: 동적할당을 위한 메모리 영역
  - Stack 영역: 지역변수, 함수 호출시 전달되는 인자를 위한 메모리 영역

- 특징

  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당 받는다.
    ![process](https://user-images.githubusercontent.com/55429912/120060193-47a94a80-c091-11eb-8dd4-7e49dca2302f.png)
  - 프로세스당 최소 1개의 스레드를 보유
  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스가 다른 프로세스의 자원에 접근하려면 IPC(Inter-process communication, 프로세스 간의 통신)를 사용해야 한다.

- 스케쥴링
  - 스케쥴링 알고리즘을 통해 **CPU 할당 순서 및 방법을 결정** 하는 일
  - 우선순위 알고리즘(Priority algorithm), 라운드 로빈 알고리즘(RoundRobin)

## 스레드란?

`프로세스 내에서 실행되는 여러 흐름의 단위`
`프로세스가 할당받은 자원을 이용하는 실행의 단위`

- 특징

  - 스레드는 프로세스내의 Code, Data, Heap영역은 공유하며 Stack영역만 따로 할당 받는다.
    ![thread](https://user-images.githubusercontent.com/55429912/120063107-82ff4580-c0a0-11eb-9e90-69ae93b72239.png)

  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 공유하며 실행된다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

- 장점
  - 메모리 공유로 인한 시스템 자원 소모가 줄어듦
  - 응답시간 단축
  - Context Switching에 대한 오버헤드가 줄어듦(Stack영역만 switching하면 되기 때문)
- 단점
  - 자원 동기화에 신경써야 함

## 자바 스레드란?

`JVM에 의해 스케쥴되는 실행 단위 코드 블럭`

- 특징
  - 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 한다.
  - 자바에는 프로세스가 존재하지 않으며, 지비 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블럭이다.
  - 스케줄링, 스레드 개수, 프로그램 코드의 메모리 위치, 상태, 우선순위 등 JVM에서 관리

## 멀티 프로세스란?

## 멀티 스레드란?

**멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.(프로세스간의 Context Switching의 경우 캐쉬 메모리에 대한 데이터까지 초기화되므로 오버헤드가 커짐) 또한 프로세스간의 통신보다 스레드간의 통신의 비용이 적으므로 작업들간의 통신의 부담이 줄어들게 됩니다.(스레드는 Stack영역을 제외한 모든 메모리를 공유하기 때문)**
멀티 스레드가 멀티 프로세스보다 좋은 이유

- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 **자원을 효율적으로 관리**할 수 있음
  - 프로세스간의 Context Switching의 경우 캐시 메모리에 대한 데이터까지 초기화 되므로 오버헤드가 커짐
- 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적고, 전환 속도가 빨라 작업들 간의 **처리 비용 감소 및 응답 시간 단축**
  - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
  - Context Switching시 스레드는 Stack 영역만 처리하기 때문

그렇다면 왜 멀티스레드만 사용하지 멀티프로세스를 쓰느냐?

**스레드간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경써야 함**

## Thread-safe란?

`멀티스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 의도한 대로 동작하는 것`

- 상호배제: Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어(Ex. Mutex, Semaphore)
- 재진입성(Reentrant): 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장
  - 해당 서브루틴에서는 공유 자원을 사용X
  - ReenTrant하다면 Thread-safe 하지만, 그 역은 성립X

## 동기화 객체
