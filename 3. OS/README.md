# OS

## `하드웨어를 관리, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어`

## 프로세스란?

`실행 중인 프로그램(= 스케줄링의 대상이 되는 작업)`

`운영체제로부터 자원을 할당받는 작업의 단위`

- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- OS로 부터 시스템 자원을 할당받는 작업의 단위
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 됨. 이 순간부터 **프로세스**라고 부름.

- 할당받는 시스템 자원

  - CPU 시간
  - 운영되기 위해 필요한 주소 공간
  - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

- 메모리 구조

  - Code 영역: 프로그램을 실행시키는 실행 파일 내의 명령어 할당
  - Data 영역: 전역변수, static 변수 할당
  - Heap 영역: 동적 할당을 위한 메모리 영역
  - Stack 영역: 지역변수, 매개변수, 리턴값 등을 위한 메모리 영역

- 특징

  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당 받는다.
    ![process](https://user-images.githubusercontent.com/55429912/120060193-47a94a80-c091-11eb-8dd4-7e49dca2302f.png)
  - 프로세스당 최소 1개의 스레드를 보유
  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스가 다른 프로세스의 자원에 접근하려면 IPC(Inter-process communication, 프로세스 간의 통신)를 사용해야 한다.

- 스케쥴링
  - 스케쥴링 알고리즘을 통해 **CPU 할당 순서 및 방법을 결정** 하는 일
  - 우선순위 알고리즘(Priority algorithm), 라운드 로빈 알고리즘(RoundRobin)

## 멀티 프로세스란?

`하나의 컴퓨터에 여러 CPU 장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)`

장점: 안정성(메모리 침범 문제를 OS차원에서 해결)

단점: 작업량이 많을수록 오버헤드 발생, Context Switching으로 인한 성능 저하

## 스레드란?

`프로세스 내에서 실행되는 여러 흐름의 단위`

`프로세스가 할당받은 자원을 이용하는 실행의 단위`

- 특징

  - 스레드는 프로세스내의 Code, Data, Heap영역은 공유하며 Stack영역만 따로 할당 받는다.
    ![thread](https://user-images.githubusercontent.com/55429912/120063107-82ff4580-c0a0-11eb-9e90-69ae93b72239.png)

  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 공유하며 실행된다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

- 장점
  - 메모리 공유로 인한 시스템 자원 소모가 줄어듦
  - 응답시간 단축
  - Context Switching에 대한 오버헤드가 줄어듦(Stack영역만 switching하면 되기 때문)
- 단점
  - 자원 동기화에 신경써야 함

## 멀티 스레드란?

`하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것`

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌

장점: 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소, 전역 변수와 정적 변수에 대한 자료 공유 가능

단점: 안정성 문제. 하나의 스레드가 데이터 공간을 망가뜨리면, 모든 스레드가 작동 불능(공유 메모리를 갖기 때문)

## 자바 스레드란?

`JVM에 의해 스케쥴되는 실행 단위 코드 블럭`

- 특징
  - 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 한다.
  - 자바에는 프로세스가 존재하지 않으며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블럭이다.
  - 스케줄링, 스레드 개수, 프로그램 코드의 메모리 위치, 상태, 우선순위 등 JVM에서 관리

## 멀티 스레드가 멀티 프로세스보다 좋은 이유?

- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 **자원을 효율적으로 관리**할 수 있음
  - 프로세스간의 Context Switching의 경우 캐시 메모리에 대한 데이터까지 초기화 되므로 오버헤드가 커짐
- 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적고, 전환 속도가 빨라 작업들 간의 **처리 비용 감소 및 응답 시간 단축**
  - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
  - Context Switching시 스레드는 Stack 영역만 처리하기 때문

그렇다면 왜 멀티스레드만 사용하지 멀티프로세스를 쓰느냐? ☞ **스레드간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경써야 함**

---

## 임계영역(Critical section)이란?

`배타적 접근(한 순간에 하나의 스레드만 접근)이 요구되는 공유 리소스에 접근하는 코드 블록`

## Thread-safe란?

`멀티스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 의도한 대로 동작하는 것`

- 상호배제: Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어(Ex. Mutex, Semaphore)
- 재진입성(Reentrant): 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장
  - 해당 서브루틴에서는 공유 자원을 사용X
  - ReenTrant하다면 Thread-safe 하지만, 그 역은 성립X

## 동기화 객체

스레드 동기화 방법

- 실행 순서의 동기화
  - 스레드의 실행순서를 정의하고, 이 순서에 반드시 따르도록 하는 것
- 메모리 접근에 대한 동기화
  - 메모리 접근에 있어서 동시접근을 막는 것
  - 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황

동기화 기법의 종류

1. 유저 모드 동기화
   `성능상 이점, 기능 적음(라이브러리를 이용)`

2. 커널 모드 동기화
   `기능상 우수, 속도 떨어짐. 각 프로세스들 안에 있는 스레드끼리의 동기화도 가능`

<table border="2">
  <tr>
    <th>모드</th>
    <th>이름</th>
    <th>사용</th>
    <th>설명</th>
  </tr>
  <tr>
    <td>유저</td>
    <td>크리티컬 섹션 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>크리티컬 섹션 오브젝트(일종의 키)라는 것을 만들고 초기화. 반드시 초기화 과정을 거쳐야 함</td>
  </tr>
  <tr>
    <td>유저</td>
    <td>인터락 함수 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>함수 내부적으로 한 순간에 하나의 쓰레드에 의해서만 실행되도록 동기화</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>뮤텍스 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>키의 취득과 반납이 이루어짐(동기화 대상이 하나)</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>세마포어 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>카운트를 통해 이루어짐(동기화 대상이 하나 이상)</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>이름있는 뮤텍스 기반 동기화</td>
    <td>프로세스간 동기화에 사용</td>
    <td>프로세스 동기화를 하기 위해서 뮤텍스를 동기화 해야하는데 커널 오브젝트는 각각 프로세스에 독립적이므로 뮤텍스에 이름을 붙여서 접근</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>이벤트 기반 동기화</td>
    <td>실행순서 동기화에 사용</td>
    <td></td>
  </tr>
</table>
<br>

---

## 세마포어(Semaphore) & 뮤텍스(Mutex)

---

**세마포어란?**

`공유된 자원의 데이터 혹은 임계영역에 여러 프로세스 혹은 스레드가 접근하는 것을 막는 것`

`(동기화 대상이 하나 이상)`

- 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
- 각 프로세스는 세마포어 값을 확인하고 변경할 수 있다.
- 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.

**뮤텍스란?**

`공유된 자원의 데이터 혹은 임계영역에 하나의 프로세스 혹은 스레드가 접근하는 것을 막는 것`

`(동기화 대상이 하나)`

- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking/unlocking을 사용
  - ex) Linux에서의 Mutex는
  ```c
  while(1) {
    pthread_mutex_lock(&mutex);   // lock
    // critical section
    pthread_mutex_unlock(&mutex); // unlock
  }
  ```

**차이점**

- **관리하는 동기화 대상의 개수**
  - 세마포어: 동기화 대상이 한개 이상
  - 뮤텍스: 동기화 대상이 한개
- 세마포어는 뮤텍스가 될수 있지만, 뮤텍스는 세마포어가 될 수 없다.(뮤텍스는 Binary Semaphore)
- 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 해당 뮤텍스를 해제할 수 있다.
- 세마포어는 세마포어를 소유하지 않는 스레드가 세마포어를 해제할 수 있다.
- 세마포어는 시스템 범위에 걸쳐 있고 파일시스템상의 파일 형태로 존재
- 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 clean up

---

## 동기와 비동기

---

**동기(Synchronous)란?**

`어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행`

- 데이터를 주고받는 **순서**가 중요할 때 사용
- 요청한 작업만 처리하면 되기 때문에 전체적인 수행 속도는 빠를 수 있음
- 한 작업에 대한 시간이 길어질 경우, 전체 응답이 지연될 수 있다.

**비동기(Asynchronous)란?**

`어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다리지 않고(작업을 위임하고) 다음 작업을 수행`

- 요청 순서에 상관없이, 동시에 다수의 작업을 처리할 수 있음
- 작업이 끝날 때 따로 이벤트를 감지하고 결과를 받아 그에 따른 추가 작업을 해줘야하기 때문에, 비교적 느릴 수 있다.
- I/O 작업이 잦고, 빠른 응답속도를 요구하는 프로그램에 적합

**Blocking vs Non-Blocking**

Bloking I/O Model

- 시스템 콜이 끝날때까지 프로그램은 대기해야 하고 시스템콜이 완료되면 그때 Return
  - ex. C언어의 scanf()
- Wait Queue에 들어감

Non-Bloking I/O Model

- 시스템 콜이 끝나지 않아도 대기하지 않고 Return
- Wait Queue에 들어가지 않음

**차이점**

1. Blocking vs Non-Blocking

- Blocking: 프로그램이 바로 실행할 수 없음
- Non-Blocking: 프로그램이 바로 실행할 수 있음

2. 동기 vs 비동기

- 동기: 시스템 콜이 끝날때까지 기다림
- 비동기: 시스템 콜이 완료되지 않아도 나중에 완료되면 그때 결과물을 가져옴

3. Non-Blocking vs 비동기

- Non-Blocking: 요청에 처리할 수 있으면 바로 응답, 아닐 경우 Error 반환
- 비동기: 요청에 처리 완료와 관계없이 응답

4. Blocking vs 동기

- Blocking: 시스템 콜이 return을 기다리는 동안 필수로 Wait Queue에 대기
- 동기: 시스템 콜이 return을 기다리는 동안 Wait Queue에 대기할 수도 안할 수도 있음

---

## 인터럽트(Interrupt)

---

`현재 실행 중인 잘업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하여 계속 처리하는 것`

**인터럽트는 왜 할까?**
`입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문`

종류

- 하드웨어 인터럽트
  - CPU가 아닌 다른 하드웨어 장치가 CPU에 어떤 사실을 알려주거나, CPU 서비스를 요청해야할 경우 발생
- 소프트웨어 인터럽트
  - 소프트웨어가 스스로 인터럽트 라인을 세팅
  - ex. 예외 상황, System call

**인터럽트를 발생 시키기 위해 HW/SW는 CPU내에 있는 인터럽트 라인을 세팅하여 인터럽트를 발생시킨다.**

**CPU는 매번 명령을 수행하기 전에 인터럽트라인이 세팅되어있는지를 검사한다.**

**과정**

![인터럽트](https://user-images.githubusercontent.com/55429912/120112394-94377780-c1b0-11eb-8277-e390ea0cc243.png)

상태 레지스터와 PC등을 스택에 잠시 저장한 뒤 인터럽트 서비스 루틴으로 이동
(인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아오기 위해!)

**만약 인터럽트 기능이 없다면?**

`컨트롤러는 특정한 어떤일을 할 시기를 알기 위해 계속 체크를 해야함(폴링 방식)`

**인터럽트와 특권 명령**
CPU 명령어의 종류

1. 일반 명령
   - 메모리에서 자료를 읽고, CPU에서 계산을 하는 등의 명령
   - 모든 프로그램이 수행할 수 있는 명령
2. 특권 명령
   - 입출력 장치, 타이머 등의 장치를 접근하는 명령
   - 보안이 필요한 명령으로 항상 **운영체제**만이 수행할 수 있다.

**운영체제의 두가지 Operation**

운영체제는 하드웨어적인 보안을 유지하기 위해 기본적으로 두가지 Opreation을 지원

1. Kernel mode: 운영체제가 CPU의 제어권을 가지고 명령을 수행하는 모드로 **일반 명령**과 **특권 명령** 모두 수행할 수 있음
2. User mode: 일반 사용자 프로그램이 CPU제어권을 가지고 명령을 수행하는 모드이기 때문에 **일반 명령**만을 수행할 수 있음

![syscall](https://user-images.githubusercontent.com/55429912/120147817-3cd1ef80-c222-11eb-8392-7a5acfa6ea29.png)

1. CPU가 인터럽트 라인을 검사(매 명령 실행 전)
2. 인터럽트 발생한 것을 감지하면, 현재 수행중인 사용자 프로그램을 멈추고 CPU의 제어권을 OS에게 양도(Kernel mode)
3. 하드웨어적으로 모드 비트가 1에서 0으로 자동으로 세팅되어 특권 명령을 수행할 수 있게 됨

`시스템 콜은 커널 영역의 기능을 사용자 모드가 사용 가능하게, 즉 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 사용할 수 있게 해준다.`

**관련 용어**

- 인터럽트 핸들러(= 인터럽트 서비스 루틴): 실제 인터럽트를 처리하기 위한 루틴, 운영체제의 코드 영역에는 인터럽트별로 처리해야할 내용이 이미 프로그램 되어 있음

- 인터럽트 벡터: 인터럽트 발생시 처리해야할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블

---

## PCB(Process Control Block)

---

**PCB(Process Control Block)란?**

`프로세스 메타데이터들을 저장해 놓는 곳`

- 한 PCB안에는 한 프로세스의 정보가 담김
- 커널의 데이터 영역에 존재
- 인터럽트 발생 시 프로세스의 메타데이터들을 저장

**PCB가 필요한 이유?**

`다시 수행할 프로세스의 상태값을 PCB에 저장해두기 위해`

**PCB 관리 방법?**

`Linked List방식으로 관리`

PCB List Head에 PCB들이 생성될 때 마다 붙게된다. 주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이하다.

**즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스가 완료되면 제거된다.**

---

## Context Switching

---

**Context Switching이란?**
`현재 진행하고 있는 작업(프로세트, 스레드)의 상태를 저장하고 다음 진행할 작업의 상태 값을 읽어 적용하는 과정`

**왜 Context Switching이 필요한가?**

- Computer가 매번 하나의 Task만 처리할 수 있다면?
  - 해당 Task가 끝날때까지 다음 Task는 기다릴 수 밖에 없음
  - 또한 반응속도가 매우 느리고 사용하기 불편
- 다양한 사람들이 동시에 사용하는 것처럼 사용하기 위해선?
  - 멀티태스킹을 통해 빠른 반응속도로 응답할 수 있음
  - 빠른 속도로 Task를 바꿔가며 실행하기 떄문에 사람의 눈으론 실시간처럼 보임
  - **CPU가 Task를 바꿔가며 실행하기 위해 Context Swtiching 필요**

**Context Switching 과정**

1. Task의 대부분 정보는 레지스터에 저장되고, PCB(Process Control Block)로 관리된다. ![pcb](https://user-images.githubusercontent.com/55429912/120107634-c6d77500-c19c-11eb-9f74-3bb2e75b4b86.png)

   **[pcb 구조]**

2. 현재 실행하고 있는 Task의 PCB정보를 저장한다.
3. 다음 실행할 Task의 PCB정보를 읽어 레지스터에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

**Context Switching 비용**

- Cache 초기화
- Memory Mapping 초기화
- Kernel은 항상 실행되어야 함(메모리의 접근을 위해서)

Process > Thread

Thread는 Stack 영역을 제외한 모든 메모리를 공유하므로, Context Switching 수행 시 Stack영역만 변경하면 되기 때문

---

## IPC(Inter-Process Communication)

---

**IPC란?**

`프로세스간 통신`

![리눅스 커널 구조](https://user-images.githubusercontent.com/55429912/120153217-69d5d080-c229-11eb-93ec-2e001d9e48ca.png)

[리눅스 커널 구조]

- 프로세스는 독립적으로 실행
- 독립된 구조인 만큼 별도의 설비가 없이 서로 간의 통신이 어려움

**IPC 종류**

<table border="2">
  <tr>
    <th style="text-align:center">이름</th>
    <th style="text-align:center">사용</th>
    <th style="text-align:center">특징</th>
  </tr>
  <tr>
    <td>익명 PIPE</td>
    <td>
      통신을 할 프로세스가 명확하게 알수 있는 경우<br>(부모 - 자식 프로세스)
    </td>
    <td>
      <ul>
        <li>
          한쪽 방향으로만 통신 가능한 <strong>Half-Duplex(반이중)통신</strong>
        </li>
        <li> 
        Full-Dulpex(전이중) 통신을 하기 위해서는 2개의 PIPE가 필요        
        </li>
    </ul>
    </td>
  </tr>
  <tr>
    <td>Named PIPE(FIFO)</td>
    <td>
      전혀 모르는 상태의 프로세스들 사이의 통신
    </td>
    <td>
      <ul>
      <li>
        프로세스 통신을 위해 이름이 있는 파일을 사용
      </li>
        <li> 
        Named PIPE의 생성은 mkfifo를 통해 이루어지며, mkfifo가 성공하면 명명된 파일이 생성됨
        </li>
        <li> 
        Full-Dulpex(전이중) 통신을 하기 위해서는 2개의 PIPE가 필요        
        </li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Message Queue</td>
    <td>메모리 공간으로 사용</td>
    <td>
      <ul>
        <li>메시지 큐에 사용할 데이터를 라벨링함으로써 여러 개의 프로세스가 데이터를 쉽게 다룰 수 있음 </li>
        <li>커널에서 관리</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Shared Memory</td>
    <td>메모리를 공유</td>
    <td>
      <ul>
        <li>프로세스간 메모리 영역을 공유해서 사용할 수 있도록 허용</li>
        <li>IPC들 중에서 가장 빠르게 작동(중재자가 없기 때문)</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Memory Map</td>
    <td>메모리를 공유</td>
    <td>
      <ul>
        <li>열린 파일을 메모리에 맵핑시켜 공유
        <br>(Shared Memory와의 차이점)</li>
        <li>메모리의 내용을 파일로 남길수 있음</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Semaphore</td>
    <td>프로세스간 데이터를 동기화 및 보호</td>
    <td>
      <ul>
        <li>Busy wait 상태에 놓이지 않음</li>
        <li>커널에서 관리되기 때문에 다른 프로세스들 간에도 사용 가능</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>Socket</td>
    <td>물리적으로 떨어져 있는 컴퓨터간의 통신</td>
    <td>
      <ul>
        <li>네트워크 통신에 사용하던 기술을 그대로 사용 가능</li>
        <li>규모가 클 경우 효율적</li>
      </ul>
    </td>
  </tr>
</table>

**커널이란?**

`메모리에 상주하는 운영체제의 부분`

- 운영체제 자체도 소프트웨어로서 메모리에 프로그램이 올라가야함
- 운영체제는 규모가 큰 프로그램으로 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심함

---

## 시스템 콜(System Call)

---

fork(), exec(), wait()와 같은 것들은 Process 생성과 제어를 위한 System call

fork(): 새로운 Process를 생성(새로운 Process를 위한 메모리를 할당)

```
Parent의 fork() 값 => child의 PID값
Child의 fork() 값 => 0
```

`Scheduler가 부모 프로세스를 먼저 수행할지 자식 프로세스를 먼저 수행할지 확실할 수 없음`

exec(): 새로운 Process를 생성(부모 프로세스의 메모리에 자식 프로세스의 코드를 덮어씌움)

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    printf("pid : %d", (int) getpid()); // pid : 29146

    int rc = fork();				    // 주목

    if (rc < 0) {
        exit(1);                        // (1) fork 실패
    }
    else if (rc == 0) {					// (2) child 인 경우 (fork 값이 0)
        printf("child (pid : %d)", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc");		// 내가 실행할 파일 이름
        myargs[1] = strdup("p3.c");		// 실행할 파일에 넘겨줄 argument
        myargs[2] = NULL;				// end of array
        execvp(myarges[0], myargs);		// wc 파일 실행.
        printf("this shouldn't print out") // 실행되지 않음.
    }
    else {								// (3) parent case
        int wc = wait(NULL)				// 추가된 부분
        printf("parent of %d (wc : %d / pid : %d)", wc, rc, (int)getpid());
    }
}
```

exec()가 실행되면, execvp(실행 파일, 전달 인자) 함수는 Code 영역에 실행 파일의 코드를 덮어 씌움. 그로 인해 execvp()이후의 부분은 실행되지 않음

wait(): Child 프로세스가 종료될 때까지 대기

```
int wc = wait(NULL); // wait()함수를 추가하여 자식프로세스 종료를 대기
```

## 데드락(교착상태, Deadlock)

---

**교착상태란?**

`두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 아무것도 완료되지 못하는 상태`

교착상태 조건

1. 상호배제(Mutual Exclusion)
   `한 번에 한 프로세스만 공유 자원을 사용할 수 있다.`
2. 점유대기(Hold and Wait)
   `공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.`
3. 비선점(No Preemption)
   `한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.`
4. 순환대기(Circular Wait)
   `두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.`

```

```
