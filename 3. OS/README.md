# OS
`하드웨어를 관리, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어`
---
## 프로세스란?

`실행 중인 프로그램(= 스케줄링의 대상이 되는 작업)`

`운영체제로부터 자원을 할당받는 작업의 단위`

- 메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)
- OS로 부터 시스템 자원을 할당받는 작업의 단위
- 하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 됨. 이 순간부터 **프로세스**라고 부름.

- 할당받는 시스템 자원

  - CPU 시간
  - 운영되기 위해 필요한 주소 공간
  - Code, Data, Stack, Heap의 구조로 되어 있는 독립된 메모리 영역

- 메모리 구조

  - Code 영역: 프로그램을 실행시키는 실행 파일 내의 명령어 할당
  - Data 영역: 전역변수, static 변수 할당
  - Heap 영역: 동적 할당을 위한 메모리 영역
  - Stack 영역: 지역변수, 매개변수, 리턴값 등을 위한 메모리 영역

- 특징

  - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당 받는다.
    ![process](https://user-images.githubusercontent.com/55429912/120060193-47a94a80-c091-11eb-8dd4-7e49dca2302f.png)
  - 프로세스당 최소 1개의 스레드를 보유
  - 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스가 다른 프로세스의 자원에 접근하려면 IPC(Inter-process communication, 프로세스 간의 통신)를 사용해야 한다.

- 스케쥴링
  - 스케쥴링 알고리즘을 통해 **CPU 할당 순서 및 방법을 결정** 하는 일
  - 우선순위 알고리즘(Priority algorithm), 라운드 로빈 알고리즘(RoundRobin)

## 멀티 프로세스란?

`하나의 컴퓨터에 여러 CPU 장착 → 하나 이상의 프로세스들을 동시에 처리(병렬)`

장점: 안정성(메모리 침범 문제를 OS차원에서 해결)

단점: 작업량이 많을수록 오버헤드 발생, Context Switching으로 인한 성능 저하

## 스레드란?

`프로세스 내에서 실행되는 여러 흐름의 단위`

`프로세스가 할당받은 자원을 이용하는 실행의 단위`

- 특징

  - 스레드는 프로세스내의 Code, Data, Heap영역은 공유하며 Stack영역만 따로 할당 받는다.
    ![thread](https://user-images.githubusercontent.com/55429912/120063107-82ff4580-c0a0-11eb-9e90-69ae93b72239.png)

  - 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름으로, 프로세스 내의 주소 공간이나 자원들을 공유하며 실행된다.
  - 한 스레드가 프로세스 자원을 변경하면, 다른 이웃 스레드(sibling thread)도 그 변경 결과를 즉시 볼 수 있다.

- 장점
  - 메모리 공유로 인한 시스템 자원 소모가 줄어듦
  - 응답시간 단축
  - Context Switching에 대한 오버헤드가 줄어듦(Stack영역만 switching하면 되기 때문)
- 단점
  - 자원 동기화에 신경써야 함

## 멀티 스레드란?

`하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것`

스레드들이 공유 메모리를 통해 다수의 작업을 동시에 처리하도록 해줌

장점: 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소, 전역 변수와 정적 변수에 대한 자료 공유 가능

단점: 안정성 문제. 하나의 스레드가 데이터 공간을 망가뜨리면, 모든 스레드가 작동 불능(공유 메모리를 갖기 때문)

## 자바 스레드란?

`JVM에 의해 스케쥴되는 실행 단위 코드 블럭`

- 특징
  - 일반 스레드와 거의 차이가 없으며, JVM이 운영체제의 역할을 한다.
  - 자바에는 프로세스가 존재하지 않으며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블럭이다.
  - 스케줄링, 스레드 개수, 프로그램 코드의 메모리 위치, 상태, 우선순위 등 JVM에서 관리

## 멀티 스레드가 멀티 프로세스보다 좋은 이유?

- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 **자원을 효율적으로 관리**할 수 있음
  - 프로세스간의 Context Switching의 경우 캐시 메모리에 대한 데이터까지 초기화 되므로 오버헤드가 커짐
- 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적고, 전환 속도가 빨라 작업들 간의 **처리 비용 감소 및 응답 시간 단축**
  - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문
  - Context Switching시 스레드는 Stack 영역만 처리하기 때문

그렇다면 왜 멀티스레드만 사용하지 멀티프로세스를 쓰느냐? ☞ **스레드간의 자원 공유는 전역 변수를 이용하므로 동기화 문제에 신경써야 함**

---

## 임계영역(Critical section)이란?
`배타적 접근(한 순간에 하나의 스레드만 접근)이 요구되는 공유 리소스에 접근하는 코드 블록`

## Thread-safe란?

`멀티스레드 환경에서 여러 스레드가 동시에 공유 자원에 접근할 때, 의도한 대로 동작하는 것`

- 상호배제: Thread-safe하기 위해서는 공유 자원에 접근하는 임계영역(critical section)을 동기화 기법으로 제어(Ex. Mutex, Semaphore)
- 재진입성(Reentrant): 여러 스레드가 동시에 접근해도 언제나 같은 실행 결과를 보장
  - 해당 서브루틴에서는 공유 자원을 사용X
  - ReenTrant하다면 Thread-safe 하지만, 그 역은 성립X

## 동기화 객체

스레드 동기화 방법
  - 실행 순서의 동기화
    - 스레드의 실행순서를 정의하고, 이 순서에 반드시 따르도록 하는 것
  - 메모리 접근에 대한 동기화
    - 메모리 접근에 있어서 동시접근을 막는 것
    - 실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황

동기화 기법의 종류
1. 유저 모드 동기화
  `성능상 이점, 기능 적음(라이브러리를 이용)`

2. 커널 모드 동기화
  `기능상 우수, 속도 떨어짐. 각 프로세스들 안에 있는 스레드끼리의 동기화도 가능`

<table border="2">
  <tr>
    <th>모드</th>
    <th>이름</th>
    <th>사용</th>
    <th>설명</th>
  </tr>
  <tr>
    <td>유저</td>
    <td>크리티컬 섹션 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>크리티컬 섹션 오브젝트(일종의 키)라는 것을 만들고 초기화. 반드시 초기화 과정을 거쳐야 함</td>
  </tr>
  <tr>
    <td>유저</td>
    <td>인터락 함수 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>함수 내부적으로 한 순간에 하나의 쓰레드에 의해서만 실행되도록 동기화</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>뮤텍스 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>키의 취득과 반납이 이루어짐(동기화 대상이 하나)</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>세마포어 기반 동기화</td>
    <td>메모리 접근 동기화에 사용</td>
    <td>카운트를 통해 이루어짐(동기화 대상이 하나 이상)</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>이름있는 뮤텍스 기반 동기화</td>
    <td>프로세스간 동기화에 사용</td>
    <td>프로세스 동기화를 하기 위해서 뮤텍스를 동기화 해야하는데 커널 오브젝트는 각각 프로세스에 독립적이므로 뮤텍스에 이름을 붙여서 접근</td>
  </tr>
  <tr>
    <td>커널</td>
    <td>이벤트 기반 동기화</td>
    <td>실행순서 동기화에 사용</td>
    <td></td>
  </tr>
</table>
<br>

---
## 세마포어(Semaphore) & 뮤텍스(Mutex)
---
**세마포어란?**

`공유된 자원의 데이터 혹은 임계영역에 여러 프로세스 혹은 스레드가 접근하는 것을 막는 것`

`(동기화 대상이 하나 이상)`
- 공유 리소스에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근하여 사용할 수 있다.
- 각 프로세스는 세마포어 값을 확인하고 변경할 수 있다.
- 세마포어를 사용하는 프로세스는 그 값을 확인하고, 자원을 사용하는 동안에는 그 값을 변경함으로써 다른 세마포어 사용자들이 기다리도록 해야한다.

**뮤텍스란?**

`공유된 자원의 데이터 혹은 임계영역에 하나의 프로세스 혹은 스레드가 접근하는 것을 막는 것`

`(동기화 대상이 하나)`
- 다중 프로세스들의 공유 리소스에 대한 접근을 조율하기 위해 locking/unlocking을 사용
  - ex) Linux에서의 Mutex는 
  ```c
  while(1) {
    pthread_mutex_lock(&mutex);   // lock
    // critical section
    pthread_mutex_unlock(&mutex); // unlock
  }
  ```
  
**차이점**
- **관리하는 동기화 대상의 개수**
  - 세마포어: 동기화 대상이 한개 이상
  - 뮤텍스: 동기화 대상이 한개
- 세마포어는 뮤텍스가 될수 있지만, 뮤텍스는 세마포어가 될 수 없다.(뮤텍스는 Binary Semaphore)
- 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 해당 뮤텍스를 해제할 수 있다.
- 세마포어는 세마포어를 소유하지 않는 스레드가 세마포어를 해제할 수 있다.
- 세마포어는 시스템 범위에 걸쳐 있고 파일시스템상의 파일 형태로 존재
- 뮤텍스는 프로세스 범위를 가지며 프로세스가 종료될 때 자동으로 clean up

---
## 동기와 비동기
---
**동기(Synchronous)란?**

`어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다린 후 다음 작업을 수행`

  - 데이터를 주고받는 **순서**가 중요할 때 사용
  - 요청한 작업만 처리하면 되기 때문에 전체적인 수행 속도는 빠를 수 있음
  - 한 작업에 대한 시간이 길어질 경우, 전체 응답이 지연될 수 있다.

**비동기(Asynchronous)란?**

`어떤 작업을 요청했을 때, 그 작업이 종료될 때까지 기다리지 않고(작업을 위임하고) 다음 작업을 수행`

  - 요청 순서에 상관없이, 동시에 다수의 작업을 처리할 수 있음
  - 작업이 끝날 때 따로 이벤트를 감지하고 결과를 받아 그에 따른 추가 작업을 해줘야하기 때문에, 비교적 느릴 수 있다.
  - I/O 작업이 잦고, 빠른 응답속도를 요구하는 프로그램에 적합

**Blocking vs Non-Blocking**

Bloking I/O Model 
- 시스템 콜이 끝날때까지 프로그램은 대기해야 하고 시스템콜이 완료되면 그때 Return
  - ex. C언어의 scanf()
- Wait Queue에 들어감

Non-Bloking I/O Model
- 시스템 콜이 끝나지 않아도 대기하지 않고 Return
- Wait Queue에 들어가지 않음

**차이점**

1. Blocking vs Non-Blocking
  - Blocking: 프로그램이 바로 실행할 수 없음
  - Non-Blocking: 프로그램이 바로 실행할 수 있음
2. 동기 vs 비동기
  - 동기: 시스템 콜이 끝날때까지 기다림
  - 비동기: 시스템 콜이 완료되지 않아도 나중에 완료되면 그때 결과물을 가져옴
3. Non-Blocking vs 비동기
  - Non-Blocking: 요청에 처리할 수 있으면 바로 응답, 아닐 경우 Error 반환
  - 비동기: 요청에 처리 완료와 관계없이 응답
4. Blocking vs 동기
  - Blocking: 시스템 콜이 return을 기다리는 동안 필수로 Wait Queue에 대기
  - 동기: 시스템 콜이 return을 기다리는 동안 Wait Queue에 대기할 수도 안할 수도 있음

---
## 인터럽트(Interrupt)
---

`현재 실행 중인 잘업을 즉시 중단하고, 발생된 상황을 우선 처리한 후 실행 중이던 작업으로 복귀하여 계속 처리하는 것`

**인터럽트는 왜 할까?**
`입출력 연산이 CPU 명령 수행속도보다 현저히 느리기 때문`

종류
- 하드웨어 인터럽트
  - CPU가 아닌 다른 하드웨어 장치가 CPU에 어떤 사실을 알려주거나, CPU 서비스를 요청해야할 경우 발생
- 소프트웨어 인터럽트
  - 소프트웨어가 스스로 인터럽트 라인을 세팅
  - ex. 예외 상황, System call

**인터럽트를 발생 시키기 위해 HW/SW는 CPU내에 있는 인터럽트 라인을 세팅하여 인터럽트를 발생시킨다.**

**CPU는 매번 명령을 수행하기 전에 인터럽트라인이 세팅되어있는지를 검사한다.**


**과정**

![인터럽트](https://user-images.githubusercontent.com/55429912/120112394-94377780-c1b0-11eb-8277-e390ea0cc243.png)

상태 레지스터와 PC등을 스택에 잠시 저장한 뒤 인터럽트 서비스 루틴으로 이동
(인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아오기 위해!)

**만약 인터럽트 기능이 없다면?**
`컨트롤러는 특정한 어떤일을 할 시기를 알기 위해 계속 체크를 해야함(폴링 방식)`

**인터럽트와 특권 명령**
CPU 명령어의 종류
1. 일반 명령
   - 메모리에서 자료를 읽고, CPU에서 계산을 하는 등의 명령
   - 모든 프로그램이 수행할 수 있는 명령
2. 특권 명령
   - 입출력 장치, 타이머 등의 장치를 접근하는 명령
   - 보안이 필요한 명령으로 항상 **운영체제**만이 수행할 수 있다.

---
## 데드락(교착상태, Deadlock)
---
**교착상태란?**

`두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에 아무것도 완료되지 못하는 상태`

교착상태 조건
1. 상호배제(Mutual Exclusion)
  `한 번에 한 프로세스만 공유 자원을 사용할 수 있다.`
2. 점유대기(Hold and Wait)
  `공유 자원에 대한 접근 권한을 갖고 있는 프로세스가, 그 접근 권한을 양보하지 않은 상태에서 다른 자원에 대한 접근 권한을 요구할 수 있다.`
3. 비선점(No Preemption)
  `한 프로세스가 다른 프로세스의 자원 접근 권한을 강제로 취소할 수 없다.`
4. 순환대기(Circular Wait)
  `두 개 이상의 프로세스가 자원 접근을 기다리는데, 그 관계에 사이클이 존재한다.`

---
## Context Switching
---

**Context Switching이란?**
`현재 진행하고 있는 작업(프로세트, 스레드)의 상태를 저장하고 다음 진행할 작업의 상태 값을 읽어 적용하는 과정`

**왜 Context Switching이 필요한가?**

- Computer가 매번 하나의 Task만 처리할 수 있다면?
  - 해당 Task가 끝날때까지 다음 Task는 기다릴 수 밖에 없음
  - 또한 반응속도가 매우 느리고 사용하기 불편
- 다양한 사람들이 동시에 사용하는 것처럼 사용하기 위해선?
  - 멀티태스킹을 통해 빠른 반응속도로 응답할 수 있음
  - 빠른 속도로 Task를 바꿔가며 실행하기 떄문에 사람의 눈으론 실시간처럼 보임
  - **CPU가 Task를 바꿔가며 실행하기 위해 Context Swtiching 필요**

**Context Switching 과정**

1. Task의 대부분 정보는 레지스터에 저장되고, PCB(Process Control Block)로 관리된다. ![pcb](https://user-images.githubusercontent.com/55429912/120107634-c6d77500-c19c-11eb-9f74-3bb2e75b4b86.png)
  
    **[pcb 구조]**

2. 현재 실행하고 있는 Task의 PCB정보를 저장한다.
3. 다음 실행할 Task의 PCB정보를 읽어 레지스터에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

**Context Switching 비용**

- Cache 초기화
- Memory Mapping 초기화
- Kernel은 항상 실행되어야 함(메모리의 접근을 위해서)

Process > Thread

Thread는 Stack 영역을 제외한 모든 메모리를 공유하므로, Context Switching 수행 시 Stack영역만 변경하면 되기 때문





