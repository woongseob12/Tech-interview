### 운영체제란?

하드웨어를 관리하고 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트 웨어

### 프로세스란?

실행중인 프로그램으로 코드, 데이터, 힙, 스택의 구조로 되어있는 독립된 메모리 영역입니다.

독립된 메모리영역이기 때문에 다른 프로세스의 자원에 접근하려면 IPC를 통해 접근이 가능합니다.
 
 - 장점: 독립된 구조로 안정성이 높음
 - 단점: 작업량이 많을수록 Context Switching으로 인한 성능 저하
  
### 스레드란?

프로세스의 실행 흐름 단위로서, 코드, 데이터, 힙영역은 공유하며 스택영역만 따로 할당받습니다.

메모리 공유로 인해 시스템 자원 소모가 줄어들고 Context Switching에 대한 오버헤드가 줄어듭니다.

(+ 스레드는 stack뿐만 아니라 Register또한 독립적인 공간이다.)
(+ 스레드는 code영역을 공유하기 때문에 한 프로세스 내부의 쓰레드들은 프로세스가 가지고 있는 함수를 모두 호출할 수 있다.)

### 스레드를 독립적으로 할당 받는 이유는?

스택영역은 함수호출시 전달인자, 지역변수 등을 저장하는 메모리 공간으로서 , 이러한 공간을 독립적으로 할당받는다는 것은 독립적으로 함수 호출이 가능하다는 것이고 이는 독립적인 실행흐름이 추가되는 것입이다. 따라서 스레드에서 실행 흐름의 추가를 위한 최소 조건이 독립된 스택을 제공하는 것입니다.

### 스레드가 PC레지스터를 독립적으로 할당 받는 이유는?

PC레지스터에는 스레드가 다음 실행해야할 명령어의 주소값이 저장되어있습니다.CPU할당시 PC레지스터에 저장된 주소값을 기준으로 이전에 멈췄던 시점부터 다시 작업을 수행해야되기 때문입니다.

### 멀티스레드가 멀티프로세스보다 좋은 이유?

멀티프로세스는 Context Switching시 발생하는 오버헤드가 크며, 서로 다른 프로세스간의 자원에 접글할 때 별도의 IPC를 통해 통신을 해야하기 때문에 멀티스레드 환경에 비해 처리비용이 좋지않고 자원의 효율성이 떨어집니다.
또한 스레드는 Context Switching시 stack영역만 처리하면 되기 때문에 응답시간이 단축됩니다.

### 스레드풀?

스레드를 제한된 개수만큼 만들어놓고 작업 큐에 들어오는 작업들을 스레드가 하나씩 맡아서 처리하는 것입니다.

작업을 실행할 때마다 스레드를 생성/제거하는 것이 아니라 제한된 수의 스레드를 미리 만들어 사용/반환 하기 때문에 생성/제거에 드는 비용을 줄임으로써 성능 저하를 방지합니다.

작업량에 비해 너무 많은 스레드를 생성했을 시에 노는 스레드가 발생할 수 있습니다.

### Thread-safe란?

멀티스레드환경에서 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이루어져도 의도한대로 동작하는 것입니다.

1. Re-entrancy: 어떤 함수를 여러 스레드가 동시에 접근해도 언제나 같은 결과를 보장
2. Thread Local Storage: 공유 자원의 사용을 최대한 줄여 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막음
3. Mutual Exclusion: 공유 자원을 사용해야할 경우 해당 자원의 접근을 뮤텍스, 세마포어 등의 동기화 작업으로 통제
4. Atomic Operation: 공유 자원에 접근할 때 원자 연산을 이용하거나, 원자적으로 정의된 접근 방버을 사용함으로써 상호배제 구현

### Context Switching이란?

현재 진행중인 작업의 상태를 저장하고 다음 진행할 작업의 상태 값을 읽어 적용하는 과정

과정
현재 실행하고 있는 Task의 정보를 PCB에 저장 → 다음 실행할 Task의 정보를 PCB로부터 읽어들여 레지스터에 적재하고, 이전에 수행했던 부분부터 작업을 진행

처리비용
프로세스 > 스레드
스레드는 스택영역을 제외한 모든 메모리 영역을 공유하기 때문에 Context switching 비용이 적게들지만 프로세스의 Context Switching은 캐시메모리가 초기화 되기 때문에 처리비용이 많이듭니다.

### 임계영역이란?

둘 이상의 스레드가 동시에 접근해서는 안되는 공유자원을 접근하는 코드의 일부입니다.

임계영역 문제를 해결하기 위해서는 3가지 조건을 충족해야 합니다.
1. 상호배제: 하나의 프로세스가 임계 영역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.
2. 진행(Progress): 임계영역에 들어간 프로세스가 없는 상태에서 들어가려하는 프로세스가 여러개라면 어느 것이 들어갈지 결정해줘야 한다.
3. 한정대기(Bounded Waiting): 다른 프로세스의 기아(Starvation)을 방지하기 위해, 한 번 임계 구역에 들어간 프로세스는 다음번 임계 구역에 들어갈때 제한을 두어야 한다.

임계 영역의 동시접근을 해결하기 위한 방법으로는 뮤텍스, 세마포어 등이 있다.

### 뮤텍스란?

공유 자원의 데이터 혹은 임계영역에 하나의 프로세스(혹은 스레드)가 접근하는 것을 막는 것입니다.

동기화 대상이 하나이며 locking 매커니즘을 통해 키를 가지고 있을때만 공유 객체에 접근이 가능하고, 임계영역의 작업을 모두 마치면 unlock을 통해 키를 반환합니다.

### 세마포어란?

공유 자원의 데이터 혹은 임계영역에 여러개의 프로세스(혹은 스레드)가 접근하는 것을 막는 것입니다.

동기화 대상이 하나이상이며 Signaling 메커니즘을 통해 통제합니다. 
세마포어는 0 이상의 정수이며 카운트 기능으로 여러개의 스레드의 접근을 제어할 수 있습니다.  

### Busy Waiting이란?

원하는 자원을 얻기 위해 기다리는 것이 아니라 **권한을 얻을 때까지 확인하는 것**을 의미합니다.

권한을 얻기 위해 많은 CPU를 낭비한다는 단점이 있고, 이는 Sleeping을 통해 해결할 수 있습니다. Sleeping은 기다리는 시간이 예측 불가능한 상황에서 주로 쓰이며, 권한을 얻기 위해 기다리는 시간을 Wait Queue에 실행 중인 Thread 정보를 담고 다른 Thread에게 CPU를 양보하는 것을 의미합니다. 커널은 권한 이벤트가 발생하면 Wait queue에 담긴 Thread를 깨워 CPU를 부여합니다.

Sleeping의 단점: Wait queue에 넣는 비용 + Context Switching 비용

spin-lock: lock을 확인하면서 얻을 때까지 기다리는 busy waiting의 일종

### 동기/ 비동기란?

`결과를 돌려주었을 때 순서와 결과에 관심이 있는지 아닌지로 판단할 수 있다`

동기: 
어떤 작업을 요청했을 때, 해당 작업 완료 여부를 신경쓰는 것

비동기:
어떤 작업을 요청했을 때, 해당 작업의 완료 여부를 신경쓰지 않는 것

### Blocking/ Non-Blocking?

`다른 주체가 작업할 때 자신의 제어권이 있는지 없는지로 볼 수 있다`

Blocking: 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 **다른 작업이 끝날때 까지 기다렸다**가 자신의 작업을 시작하는 것
Non-Blocking: 다른 주체의 작업에 **상관없이** 자신의 작업을 하는 것

### 인터럽트란?


![image](https://user-images.githubusercontent.com/55429912/121231200-16b7e980-c8cb-11eb-931c-c55cc77053ff.png)

CPU가 프로그램을 실행하고 있을때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요한 경우 CPU에게 알려 처리할 수 있도록 하는 것

1. 현재 실행중이던 명령어 사이클의 실행단계를 완료하고 CPU는 반복적으로 인터럽트 요청이 있는지 확인한다.
2. 인터럽트 가능플래그가 set되어있고 인터럽트 요청이 들어오면 프로그램을 중단하고 프로그램의 상태(PC, SR(Status Register))를 보관한다.
3. 인터럽트를 처리하기 위해 인터럽트 벡터에서 인터럽트 서비스 루틴에 대한 정보를 찾고 인터럽트를 수행한다.
   - 인터럽트 서비스 루틴(= 인터럽트 핸들러): 실제 인터럽트를 처리하기 위한 루틴으로 OS 코드영역에는 인터럽트별로 처리해야할 내용이 프로그램 되어있음
4. 인터럽트 처리가 완료되면 스택에 저장되어있던 PC와 SR값이 복구된다.
5. 프로그램을 재실행한다.


### 메모리 할당 알고리즘

1. First-fit: 메모리를 처음부터 검사하여 가장 첫번째로 사용 가능한 공간에 할당
   - 빠른 메모리 할당 가능
   - 공간 활용률 떨어짐
2. Best-fit: 메모리 공간중 프로세스가 들어갈 수 있는 가장 작은 공간에 할당
   - 공간 활용률 높아짐
   - 메모리가 크기순으로 정렬되있지 않다면 검색시간이 늘어남
3. Next-fit: 메모리 공간중 가장 큰 콧에 할당
   - 큰 메모리에 바로 할당하므로 검색이 빠르다
   - 사용 가능한 메모리의 정렬이 필요하고 공간 활용률이 떨어짐