# Database

## 키(Key)

`검색이나 정렬 시 튜플을 구분할 수 있는 기준이 되는 속성`

튜플: 릴레이션을 구성하는 각각의 행, 속성의 모임
   - 튜플의 수 = 카디널리티(Cardinality)

1. 후보키(Candidate Key)
   - 튜플을 유일하게 식별할 수 있는 속성들의 부분 집합
     - 기본키로 사용할 수 있는 속성들
   - 모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 함
   - 릴레이션의 모든 튜플에 대해서 **유일성**과 **최소성**을 만족시켜야 함
     - 유일성: Key로 하나의 튜플을 유일하게 식별할 수 있음
     - 최소성: 꼭 필요한 속성으로만 구성

2. 기본키(Primary Key)
   - 후보키 중 선택한 메인 키
   - 한 릴레이션에서 **특정 튜플을 유일하게 구별할 수 있는 속성**
   - Null값을 가질 수 없음
   - 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음
      - 개체 무결성: 기본키가 가지고 있는 값의 유일성을 보장받아야 함

3. 대체키(Alternate Key)
   - 후보키가 둘 이상일 때, 기본 키를 제외한 나머지 후보키
   - 보조키라고도 함

4. 슈퍼키(Super Key)
   - 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키
   - 유일성은 만족하지만, 최소성은 만족시키지 않음
  
5. 외래키(Foreign Key)
   - 관계를 맺고 있는 릴레이션 R1, R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성
   - 참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는데 중요한 도구로 사용됨
   - 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없음

## 스키마(Schema)

`데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것`

- 속성, 개체, 관계에대한 정의, 제약 조건등을 기술

![image](https://user-images.githubusercontent.com/55429912/120893143-9ab06e00-c64c-11eb-9741-48f1f3b4b0e6.png)

1. 외부 스키마(External Schema)
   - 사용자 View
   - 사용자의 입장에서 정의한 DB의 논리적 구조
   - 하나의 데이터베이스 시스템에는 여러개의 외부 스키마가 존재할 수 있음
   - 하나의 외부 스키마를 여러개의 응용 프로그램이나 사용자가 공용할 수 있음

2. 개념 스키마(Coneptual Schema)
   - 전체적인 View
   - DB의 전체적인 논리적 구조를 기술하기 때문에 DB에 하나만 존재하며, 통상 스키마라 하면 개념 스키마를 일컫음
  
3. 내부 스키마(Internal Schema)
   - 저장 스키마(Storage Schema)
   - 실제로 데이터베이스에 저장될 레코드의 물리적인 구조를 정의
  
---

## 조인(Join)

`두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법`

- 테이블을 연결하려면 적어도 하나의 컬럼을 서로 공유하고 있어야 하므로 이를 이용하여 데이터 검색에 활용

![image](https://user-images.githubusercontent.com/55429912/120887283-e05d3e80-c62c-11eb-89da-c4284c1ef529.png)

## SQL Injection

`조작된 SQL 쿼리문이 DB에 그대로 전달되어 비정상적 명령을 실행시키는 공격 기법`

**공격 방법**

- 논리적 에러를 이용한 SQL Injection

![image](https://user-images.githubusercontent.com/55429912/120887419-b5271f00-c62d-11eb-998b-4737bec1babe.png)

**방어 방법**

- Input 값 입력 받을 경우, 특수 문자 여부 검사하기
- SQL 서버 오류 발생시, 해당하는 에러 메시지 감추기
- prepare statement 사용하기
  - prepare statement를 사용하면 특수문자를 자동으로 escaping 해줌

## SQL & NoSQL

- SQL: RDBMS에서 데이터를 저장, 수정, 삭제 및 검색 할 수 있음
  - 정해진 데이터 스키마에 따라 테이블에 저장
  - 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없음
- NoSQL: 스키마도 없고, 관계도 없는 DB
  - 서로 다른 구조의 데이터를 같은 컬렉션에 추가 가능

**확장**

- 수직적 확장: 데이터베이스 서버의 성능을 향상시키는 것
- 수평적 확장: 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨

**장단점**

- SQL
   - 장점
     - 명확하게 정의된 스키마, 데이터 무결성 보장
     - 관계는 각 데이터를 중복없이 한번만 저장
   - 단점
     - 유연하지 않음
     - 조인문이 많은 복잡한 쿼리가 만들어질 수 잇음
     - 대체로 수직적 확장만 가능

- NoSQL
  - 장점
    - 스키마가 없어서 유연함
    - 데이터를 애플리케이션에서 필요한 형식으로 저장(데이터 읽어오는 속도 향상)
    - 수직 및 수평 확장이 가능
  - 단점
    - 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
    - 데이터 중복을 계속 업데이트 해야함
    - 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수행해야 함
  


## 정규화(Normalization)

`관계형 데이터베이스에서 데이터 중복을 최소화 하기 위해 데이터를 구조화 하는 작업`

**목적**

- 이상 현상 제거
  1. 삽입 이상: 새로운 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입
  2. 갱신 이상: 반복된 데이터중 일부를 갱신할 경우 데이터의 불일치 발생
  3. 삭제 이상: 데이터를 삭제하기 위해 필요한 데이터도 함께 삭제
- 데이터 베이스 구조 확장 시 재 디자인 최소화
- 사용자에게 데이터 모델을 더욱 의미있게 제공

**종류**

1. 제 1 정규형(First Normal Form, 1NF)

   ![image](https://user-images.githubusercontent.com/55429912/120803172-3cb55500-c57e-11eb-8474-48a988b4050c.png)

   `속성의 원자성(Atomic)을 확보, 기본키를 설정`

2. 제 2 정규형(Second Normal Form, 2NF)

   ![image](https://user-images.githubusercontent.com/55429912/120803386-76865b80-c57e-11eb-8953-a9536b26912c.png)

   `기본키가 2개 이상의 속성으로 이루어진 경우, 부분 함수 종속성 제거`

3. 제 3 정규형(Third Normal Form, 3NF)

   ![image](https://user-images.githubusercontent.com/55429912/120804048-28be2300-c57f-11eb-8225-18d02de76be0.png)

   `이행 함수 종속성 제거`

**함수적 종속성이란?**

`X의 값을 알면 Y의 값을 바로 식별할 수 있고, X의 값에 Y의 값이 달라질 때, Y는 X에 함수적 종속이라고 한다.`

- X를 결정자, Y를 종속자(X → Y)

1. 완전 함수적 종속(Full Functional Dependency)
   
   ![image](https://user-images.githubusercontent.com/55429912/120884906-e3eac880-c620-11eb-9437-5422cf08bc2e.png)

   - **종속자가 기본키에만 종속**되어 있음
  
   ![image](https://user-images.githubusercontent.com/55429912/120884937-1399d080-c621-11eb-8b15-932e18468cb3.png)

   - 기본키가 여러 속성으로 구성되어 있을 경우, **기본키를 구성하는 모든 속성이 포함된 기본키의 부분집합에 종속**된 경우
  
2. 부분 함수적 종속

   ![image](https://user-images.githubusercontent.com/55429912/120884971-49d75000-c621-11eb-9ee7-b66aea863c9a.png)

   - **종속자가 기본키가 아닌 다른 속성에 종속**되거나, 기본키가 여러 속성으로 구성되어 있을 경우 **기본키를 구성하는 속성중 일부만 종속**되는 경우


3. 이행적 함수 종속

   ![image](https://user-images.githubusercontent.com/55429912/120885300-2f9e7180-c623-11eb-8aaa-810786782b7a.png)

   - 릴레이션에서 X, Y, Z라는 3개의 속성이 있을 때, **X → Y → Z란 종속 관계가 있을 경우, X → Z가 성립**되는 경우

---

## 인덱스(Index)

`데이터의 위치를 빠르게 찾아주는 역할`

**구조**

1. Hash
   - 컬럼의 값으로 생성된 해시 기반으로 인덱스를 구현, 탐색시 O(1)이라 검색이 매우 빠르지만, 부등호와 같은 연속적인 데이터를 위한 순차 검색이 불가능
2. B+Tree
   - 범위 연산에 우수하여 주로 사용

**장단점**

- Table의 Record를 Full scan 하지 않고, Index 파일 검색으로 검색 속도 향상
- 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듦
- 인덱스된 필드에서 데이터를 삽입, 삭제, 수정시 성능이 떨어짐


## 트랜잭션(Transaction)

`하나의 논리적 작업 단위를 구성하는 일련의 연산들의 집합`

**특성(ACID)**

1. 원자성(Atomicity)
   - 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.
2. 일관성(Consistency)
   - 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
3. 독립성(Isolation)
   - 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
4. 지속성(Durability)
   - 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.

**연산**

Commit

- 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일때 이를 알려주기 위해 사용하는 연산

Rollback

- 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우
- transaction이 정상적으로 종료되지 않았을 때, last consistent state로 roll back 할 수 있음

**상태**

- 활동(Active)
  - 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태
- 장애(Failed)
  - 트랜잭션이 실행에 오류가 발생하여 중단된 상태
- 철회(Aborted)
  - 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
- 부분 완료(Paritally Committed)
  - 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
- 완료(Committed)
  - 트랜잭션이 성공적으로 정료되어 Commit 연산을 실행한 후의 상태 

**격리 수준(Isolation level)**

`트랜잭션에서 일관성 업는 데이터를 허용하도록 하는 수준`

- DB는 ACID특성에 의해 트랜잭션이 독립적인 수행하도록 해야 함
- Locking을 통해 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막야아 함
  - Locking 범위 ↑, 데이터베이스 성능 ↓
  - Locking 범위 ↓, 잘못된 값이 처리될 가능성 ↑

1. Read Uncommitted(레벨 0)
   - `트랜잭션에 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용`
     - DB의 일관성을 유지하는 것이 불가능
     - Dirty Read, Non-Repeatable Read, Phantom Read

2. Read Committed(레벨 1)
   - `트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨`
     - Commit이 이루어진 트랜잭션만 조회 가능
     - SQL 서버가 Default로 사용하는 Isolation level
     - Non-Repeatable Read, Phantom Read

3. Repetable Read(레벨 2)
   - `트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장`
     - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능
     - Phantom Read

4. Serializable(레벨 3)
   - `완벽한 읽기 일관성 모드를 제공`
     - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력 이 불가능

Dirty Read: 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 경우

Non-Repeatable Read: 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써 두 쿼리의 결과가 상이하게 나타나는 비일관성 현상

Phantom Read: 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상


---

## 커넥션 풀(Connection Pool)

![image](https://user-images.githubusercontent.com/55429912/120885589-c4ee3580-c624-11eb-96a5-16ea9e9d3a59.png)

`Connection을 여러개 생성해 두어 저장해 놓은 공간(캐시), 또는 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법`

- 클라이언트의 요청에 따라 각 어플리케이션의 스레드에서 DB에 접근하기 위해선는 Connection이 필요

**접근 방법**

![image](https://user-images.githubusercontent.com/55429912/120885679-18f91a00-c625-11eb-859b-59d283af9d12.png)

1. 웹 컨테이너가 실행되면서 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장
2. DB에 요청시 pool에 있는 Connection 객체를 가져과 DB에 접근
   - Connection이 부족하다면?
     - 모든 요청이 DB에 접근하고 남은 Connection이 없다면, 해당 클라이언트는 대기 상태로 전환시키고 pool에 connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공됨 
3. 처리가 끝나면 다시 pool에 반환

**사용 이유**

- 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있음
- 미리 생성된 Connection 객체를 사용하기 때문에 DB접근 시간이 단축됨
- DB에 접근하는 Connection 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있음

**비슷한 개념으로는?**

Thread pool
- 매 요청마다 요청을 처리할 스레드를 만드는 것이 아닌, 미리 생성한 pool내의 스레드를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법

- WAS에서 스레드풀과 커넥션풀 내의 스레드와 커넥션의 수는 직접적으로 메모리와 관련이 있기 때문에, 많이 사용하면 할수록 메모리를 많이 점유하게 됨
- 메모리를 위해 적게 지정한다면, 서버에서는 많은 요청을 처리하지 못하고 대기할 수 밖에 없음
- WAS의 스레드수가 커넥션 수보다 많은 것이 좋음
  - 모든 요청이 DB에 접근하는 작업이 아니기 때문