# Computer Arhitecture

## 컴퓨터의 구성

**하드웨어**

![image](https://user-images.githubusercontent.com/55429912/120900328-37840300-c66f-11eb-9eca-6ef75979598c.png)

`컴퓨터를 구성하는 기계적 장치`

1. 중앙처리 장치(CPU)

- `주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어함`
  - 산술논리연산장치(ALU): 비교와 연산을 담당
  - 제어장치: 명령어의 해석과 실행을 담당
  - 레지스터: 속도가 빠른 데이터 기억장소

2. 기억 장치

- `프로그램, 데이터, 연산의 중간 결과 등을 저장하는 장치`
  - 주기억 장치
    - ROM(Read-only Memory): 비휘발성 메모리, 기억된 내용을 읽은 수는 있지만 바꿀수는 없음
    - RAM(Random-access Memory): 휘발성 메모리, 연산결과를 저장하거나 다음 연산에 상용하는 등 상황에 따라 편리하게 사용할 수 있는 범용 메모리
  - 보조 기억 장치
    - 비휘발성
    - CPU와 직접적인 데이터 교환X

3. 입출력 장치

**소프트웨어**

- 시스템 소프트웨어
  - 운영체제, 컴파일러
- 응용 소프트웨어
  - 워드 프로세서, 스프레드시트

---

## 시스템 버스

![image](https://user-images.githubusercontent.com/55429912/120900779-c8f47480-c671-11eb-8dff-3755d388adaa.png)

`컴퓨터의 구성요소를 서로 연결하고 데이터 전달을 위한 통로`

1. 데이터 버스(Data Bus)

- `중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로`
  - 기억장치, 입출력장치의 명령어와 데이터를 중앙 처리장치로 보내거나, 중앙처리장치의 연산 결과를 기억장치, 입출력장치로 보내는 **양방향버스**

2. 주소 버스(Address Bus)
   - `메모리의 주소를 전달하는 통로`
     - 중앙처리장치가 주기억장치나 입출력장치로 기억장치 주소를 전달하는 **단방향버스**
3. 제어 버스(Control Bus)
   - `중앙처리장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로`
     - 읽기 동작과 쓰기 동작을 모두 수행하는 **양방향버스**

컴퓨터는 기본적으로 읽고 처리한 뒤 저장하는 과정으로 이루어짐
(READ → PROCESS → WRITE)

CPU는 RAM으로부터 데이터를 읽어 올때 한번에 운영체제의 bit 크기만큼 읽어옴
bit 크기는 **명령을 한번에 처리할 수 있는 레지스터의 비트 크기**
word: 레지스터에 옮겨 놓을 수 있는 데이터 단위

- 32bit 컴퓨터 CPU의 레지스터 처리값: 32bit
- 64bit 컴퓨터 CPU의 레지스터 처리값: 64bit

## 레지스터

`특정한 목적에 사용되는 일시적인 기억장치, 데이터를 읽고 쓰는 기능이 매우 빠르며, 중앙 처리 장치(CPU) 내부에 사용됨`

**종류**

1. 범용 레지스터(General Purpose Register)
2. 특수 레지스터

- 특별한 용도로 사용하는 레지스터
  - MAR(메모리 주소 레지스터): 읽기와 쓰기 연산을 수행할 주기억장치 주소 저장
  - PC(프로그램 카운터): 다음 수행할 명령어 주소 저장
  - IR(명령어 레지스터): 현재 실행중인 명령어 저장
  - MBR(메모리 버퍼 레지스터): 주기억장치에서 읽어온 데이터 or 저장할 데이터 임시 저장
  - AC(누산기): 연산 결과 임시 저장

**CPU의 동작 과정**

1. 주기억장치는 입력장치에서 입력받은 데이터 또는 보조기억장치에 저장된 프로그램 읽어옴
2. CPU는 프로그램을 실행하기 위해 주기억장치에 저장된 프로그램 명령어와 데이터를 읽어와 처리하고 결과를 다시 주기억장치에 저장
3. 주기억장치는 처리 결과를 보조기억장치에 저장하거나 출력장치로 보냄
4. 제어장치는 1 ~ 3번 과정에서 명령어가 순서대로 실행되도록 각 장치를 제어

**CPU의 명령어 싸이클**

![image](https://user-images.githubusercontent.com/55429912/120902197-df063300-c679-11eb-9fc2-79b23b2f285a.png)

`한 개의 명령어가 CPU에서 수행되는데 필요한 전체 수행 과정`

- 인출(Fetch)
  - 기억장치에 있는 명령어를 인출하는 과정
- 실행(Execute)
  - 명령어를 실행하는 단계로 IR레지스터에 실린 명령어를 해독하고, 해독한 명령어에 따라 필요한 연산이 수행되는 과정
- 간접(Indirect)
  - 간접주소지정방식을 사용하는 명령어에서 Operand 부분의 유효 주소를 결정하는 과정
- 인터럽트(Interrupt)
  - CPU가 현재 처리 중인 프로그램 루틴을 중단시키고 다른 동작을 수행하도록 하는 과정

## 실수 표현

컴퓨터에서 실수를 표현하는 방법은 `고정 소수점`과 `부동 소수점` 두가지 방식이 존재한다.

1. 고정 소수점(Fiexd Point)

![image](https://user-images.githubusercontent.com/55429912/120923582-5c798400-c70a-11eb-8961-1acf2a5c5ed2.png)

`소수점이 찍힐 위치를 미리 정해놓고 소수를 표현하는 방식`

장점

- 실수를 정수부와 소수부로 표현하여 단순
  단점
- 표현의 범위가 너무 적어서 활용하기 힘듦

2. 부동 소수점(Floating Point)

![image](https://user-images.githubusercontent.com/55429912/120923726-fd683f00-c70a-11eb-9f9d-faecba1f2966.png)

`실수를 가수부 + 지수부로 표현하는 방식`

- 소수점의 위치가 고정되지 않고, 지수의 값에 따라 움직임

장점

- 표현할 수 있는 수의 범위가 넓어짐
  단점
- 오차가 발생할 수 있음

## 패리티 비트 & 해밍 코드

**패리티 비트란?**

![image](https://user-images.githubusercontent.com/55429912/120923894-ed9d2a80-c70b-11eb-9cda-62b4f7777915.png)

`정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트`

- 1Byte(8bit)구조에서 패리티 비트는 7비트 크기의 ASCII 코드를 제외한 나머지 1비트
- 1의 개수가 짝수(짝수 패리티비트)나 홀수(홀수 패리티비트)개가 되도록 함

**해밍 코드란?**

`스스로 데이터 오류를 찾아낼 수 있는 코드`

- 필요한 체크비트 수?

  ![image](https://user-images.githubusercontent.com/55429912/120924045-acf1e100-c70c-11eb-940e-6261467eda8b.png)

- 체크비트 삽입 위치?

  ![image](https://user-images.githubusercontent.com/55429912/120924079-db6fbc00-c70c-11eb-9acc-24157e182a29.png)

  `2^n 위치로 순서대로 삽입`

- 풀이

  ```
  짝수 패리티의 해밍코드가 0011011일 때, 오류가 수정된 코드는?

  1. 1, 3, 5, 7번째 비트 확인: 0101로 짝수이므로 '0'

  2. 2, 3, 6, 7번째 비트 확인: 0111로 홀수이므로 '1'

  3. 4, 5, 6, 7번째 비트 확인: 1011로 홀수이므로 '1'

  역순으로 패리티 비트 '110'을 도출, 110(2) = 6이므로 6번째 비트를 수정

  0011011 ⇒ 0011001

  ```

---

## Datapath

`Datapath란 CPU에서 데이터와 주소를 처리하는 요소`

- 레지스터, ALU, MUX, 메모리 등..

  - MUX(Multiplexer): 여러 개의 입력 신호 중 원하는 신호를 선택해서 출력하는 회로

  ![image](https://user-images.githubusercontent.com/55429912/120996869-b0936f80-c7c1-11eb-8dd7-30d85cabb456.png)

---

## 파이프라인

![image](https://user-images.githubusercontent.com/55429912/120924766-37880f80-c710-11eb-880c-9b195ef348f6.png)

`병렬 처리 방식`

- 동시에 여러 개의 명령어를 처리함으로써 처리량을 올리는것
- **처리량을 늘리는 것**이지 ~~원래의 동작 속도를 단축시키는 것~~은 아님
- 각 단계별 처리 시간이 일정할수록 효율성↑

**등장 이유?**

- 단일 사이클의 한계
- 한 클럭동안 하나의 명령어를 수행
- 클럭 사이클이 모든 명령어에 대한 같은 길이를 갖음
- 클럭 사이클이 너무 길어 비효율적(클럭 사이클은 가장 긴 명령어에 맞춰야 하기 때문)

### 파이프라인의 5단계

1. IF(Instruction Fetch)

- 메모리에서 **명령어를 가져옴**

2. ID(Instruction Decode)

- 명령어를 읽고/해독 , 레지스터를 읽음
- MIPS명령어는 형식이 **규칙적이어서 읽기/해독이 동시에 일어난다.**

3. EX(Execute)

- **연산** 수행 or **주소 계산**

4. MEM(Meomory access)

- 데이터 메모리에 있는 피연산자의 접근

5. WB(Wirteback)

- 결과값을 레지스터에 쓴다

### 파이프라인 해저드

`다음 명령어가 다음 클럭 사이클에 실행될 수 없는 상황`

1. 구조적 해저드

![image](https://user-images.githubusercontent.com/55429912/120964097-b2e3d280-c79d-11eb-9d74-f1c2fc1b58e7.png)

- 다른 단계에 있는 명령어들이 동시에 같은 자원 사용하려하는 상황
- Stall, 파이프라인 버블, 충분한 자원 확보를 통해 해결
  - 파이프라인 스톨(pipeline stall): 파이프라인 처리가 중도에 끊어지는 것
  - 파이프라인 버블(pipeline bubble): 파이프라인의 빈공간

2. 데이터 해저드

![image](https://user-images.githubusercontent.com/55429912/120968727-30aadc80-c7a4-11eb-8166-59e2bc891584.png)

- 현재 수행해야할 명령의 값이 이전 명령의 값에 종속되어 있을때 발생
- **RAW**(Read After Write) 해저드(basic five-stage pipeline에서 문제 발생)
  - 이전 명령이 저장한 연산 결과를 후속 명령이 읽으려고 할 때 발생
  - A = B + C; D = A + E;
- WAR(Wirte After Read) 해저드
  - 이전 명령이 값을 읽기 전에, 후속 명령이 값을 쓰는 경우에 발생
  - A = B + C; B = D + E;
- WAW(Wirte After Wirte) 해저드
  - 이전 명령이 값을 쓰기 전에, 후속 명령이 값을 쓰는 경우에 발생
- 포워딩을 통해 해결
  ![image](https://user-images.githubusercontent.com/55429912/120966644-7914cb00-c7a1-11eb-937b-438da5868827.png)

  - 포워딩(Forwarding): ALU 출력 결과를 가져오는 회로를 추가하여 다음 명령어에서 읽기 대상인 레지스터를 이전 명령어가 쓰기 하려고 할 때 이전 명령어의 출력 결과를 선택하게끔하는 방법
  - 포워딩으로 모든 데이터 헤저드를 해결할 순 없음

3. 제어 해저드

- 분기(Jump나 Brunch 등) 명령어들로 인해 다른 명령어들이 실행 중에 한 명령어의 결과 값에 기반을 둔 결정을 할 필요가 있을 때 발생
- 분기를 결정하는 시점에 잘못된 명령이 파이프라인에 있을 경우 발생
- 지연, 예측, 지연로 해결
  - 지연: 분기시마다 지연
  - 예측: 분기가 항상 실패 또는 성공한다고 예측
  - 분기 지연(Delayed branch): 분기가 필요한 명령어의 결과값이 나오는 동안 해당 분기와 관련이 없는 다른 명령어를 먼저 실행하여 시간이 지연되지 않도록 하는 방법(컴파일 최적화를 통해 이루워짐)
