# Data Structure

## 배열(Array)

- 논리적 저장순서와 물리적 저장순서가 일치
- 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다.
  - 즉, Random Access가 가능하다.
- 데이터 삽입, 삭제시 처리후 전체적으로 Shift해줘야 하기 때문에 O(N)의 시간 복잡도를 갖는다.

## 링크드리스트(LinkedList)

![image](https://user-images.githubusercontent.com/55429912/120528055-fb099a80-c415-11eb-8795-07c1ef2c2075.png)

`연속적이지 않은 메모리 위치에 저장되는 선형 데이터 구조`

- 논리적 저장 순서와 물리적 저장 순서가 다름
  - 데이터를 검색 시 처음 노드부터 순회해야함(O(N)의 시간 복잡도)
- 메모리 공간 상에서 각 노드들이 연속적으로 이루어져있지 않고, 각각의 노드가 다음 노드의 위치를 알고 있는 형태
- 원소를 삽입/ 삭제 시 그 원소를 찾기 위해 O(N)의 시간이 발생하고, 추가적으로 데이터를 삽입/ 삭제하는 경우 O(1)의 시간이 걸려 완료하는데 총 O(N)의 시간이 걸립니다.
  - 즉, 만약 삽입/ 삭제하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간 복잡도를 가짐

### 배열 VS 링크드 리스트

|자료구조|접근|삽입|삭제|
|:---:|:---:|:---:|:---:|
|배열|O(1)|O(N)/ 맨 뒤일 경우 O(1)|O(N)/ 맨 뒤일 경우 O(1)|
|배열|O(N)|O(N)/ 맨 앞일 경우 O(1)|O(N)/ 맨 앞일 경우 O(1)|

**메모리 할당**

- 배열
  - 정적 메모리
  - Array 선언되자 마자 Complie time에 할당
- LinkedList
  - 동적 메모리
  - 새로운 Node가 추가될 때 run time에 할당

```
데이터 접근, 탐색이 중요 ⇒ 배열
데이터 추가, 삭제가 중요 ⇒ 링크드리스트
```

## ArrayList

- 크기가 가변적

## 스택(Stack)

`LIFO(Last In First Out)의 선형 자료구조`

- 함수의 콜스택, 문자열 역순 출력 등에 사용

## 큐(Queue)

`FIFO(First In First Out)의 선형 자료구조`

- 너비우선탐색, OS의 Ready 큐 등에 사용

## 힙(Heap)

![image](https://user-images.githubusercontent.com/55429912/120530590-aa477100-c418-11eb-9da6-d12bcd873b58.png)

`완전 이진 트리의 일종으로 여러 값중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조`

검색(최대값or최솟값): O(1)
삽입: O(logN)
삭제: O(logN)

**힙 트리는 중복된 값 허용(이진 탐색 트리는 중복 값 허용 X)**

- 배열을 기반으로 한 완전 이진 트리(Complete Binary Tree)
  - 왼쪽 자식 노드: 현재 노드 * 2
  - 오른쪽 자식 노드: 현재노드 * 2 + 1
  - Index를 통한 Random Access 가능
- 힙의 종류로는 최대 힙과 최소 힙이 존재
  - 최대 힙: 부모 노드의 키 값 >= 자식 노드의 키 값
  - 최소 힙: 부모 노드의 키 값 <= 자식 노드의 키 값
  - 최대 최소 값을 찾는데 O(1)의 시간 소요 ⇒ Root Node의 값이 최대or 최소 이기 때문

**구현**

삽입:
1. 새로운 요소가 들어오면 힙의 마지막 노드에 삽입
2. 새로운 노드를 부모 노드와 비교하여 교환

삭제:
1. 최대/최소 값은 루트 노드이므로 루트 노드가 삭제
2. 마지막 노드의 값을 루트에 대입
3. 힙을 재구성

