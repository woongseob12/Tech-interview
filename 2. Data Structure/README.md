# Data Structure

## 배열(Array)

- 논리적 저장순서와 물리적 저장순서가 일치
- 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다.
  - 즉, Random Access가 가능하다.
- 데이터 삽입, 삭제시 처리후 전체적으로 Shift해줘야 하기 때문에 O(N)의 시간 복잡도를 갖는다.

---

## 링크드리스트(LinkedList)

![image](https://user-images.githubusercontent.com/55429912/120528055-fb099a80-c415-11eb-8795-07c1ef2c2075.png)

`연속적이지 않은 메모리 위치에 저장되는 선형 데이터 구조`

- 논리적 저장 순서와 물리적 저장 순서가 다름
  - 데이터를 검색 시 처음 노드부터 순회해야함(O(N)의 시간 복잡도)
- 메모리 공간 상에서 각 노드들이 연속적으로 이루어져있지 않고, 각각의 노드가 다음 노드의 위치를 알고 있는 형태
- 원소를 삽입/ 삭제 시 그 원소를 찾기 위해 O(N)의 시간이 발생하고, 추가적으로 데이터를 삽입/ 삭제하는 경우 O(1)의 시간이 걸려 완료하는데 총 O(N)의 시간이 걸립니다.
  - 즉, 만약 삽입/ 삭제하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간 복잡도를 가짐

### 배열 VS 링크드 리스트

|  자료구조  | 접근 |          삽입           |          삭제           |
| :--------: | :--: | :---------------------: | :---------------------: |
|   Array    | O(1) | O(N)/ 맨 뒤일 경우 O(1) | O(N)/ 맨 뒤일 경우 O(1) |
| LinkedList | O(N) | O(N)/ 맨 앞일 경우 O(1) | O(N)/ 맨 앞일 경우 O(1) |

**메모리 할당**

- Array
  - 정적 메모리
  - Array 선언되자 마자 Complie time에 할당
- LinkedList
  - 동적 메모리
  - 새로운 Node가 추가될 때 run time에 할당

```
데이터 접근, 탐색이 중요 ⇒ 배열
데이터 추가, 삭제가 중요 ⇒ 링크드리스트
```

---

## ArrayList

- 크기가 가변적

---

## 스택(Stack)

`LIFO(Last In First Out)의 선형 자료구조`

- 함수의 콜스택, 문자열 역순 출력 등에 사용

---

## 큐(Queue)

`FIFO(First In First Out)의 선형 자료구조`

- 너비우선탐색, OS의 Ready 큐 등에 사용

---

## 트리(Tree)

![image](https://user-images.githubusercontent.com/55429912/120596118-4eafce80-c47e-11eb-9f0c-5bc33705f0d0.png)

`계층적 관계를 표현하는 비선형 자료구조`

- 사이클이 없는 그래프의 한 종류
  - Directed Acyclic Graph: 방향성이 있는 비순환 그래프
- 노드와 간선으로 구성됨
  - 노드: N개
  - 간선: N- 1개
- 임의의 두 노드간의 경로는 유일하다.

---

## 힙(Heap)

![image](https://user-images.githubusercontent.com/55429912/120530590-aa477100-c418-11eb-9da6-d12bcd873b58.png)

`완전 이진 트리의 일종으로 여러 값중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조`

검색(최대값or최솟값): O(1)
삽입: O(logN)
삭제: O(logN)

**힙 트리는 중복된 값 허용(이진 탐색 트리는 중복 값 허용 X)**

- 배열을 기반으로 한 완전 이진 트리(Complete Binary Tree)
  - 왼쪽 자식 노드: 현재 노드 \* 2
  - 오른쪽 자식 노드: 현재노드 \* 2 + 1
  - Index를 통한 Random Access 가능
- 힙의 종류로는 최대 힙과 최소 힙이 존재
  - 최대 힙: 부모 노드의 키 값 >= 자식 노드의 키 값
  - 최소 힙: 부모 노드의 키 값 <= 자식 노드의 키 값
  - 최대 최소 값을 찾는데 O(1)의 시간 소요 ⇒ Root Node의 값이 최대or 최소 이기 때문

**구현**

삽입:

1. 새로운 요소가 들어오면 힙의 마지막 노드에 삽입
2. 새로운 노드를 부모 노드와 비교하여 교환

삭제:

1. 최대/최소 값은 루트 노드이므로 루트 노드가 삭제
2. 마지막 노드의 값을 루트에 대입
3. 힙을 재구성

---

## 이진 탐색 트리(BST, Binary Search Tree)

![image](https://user-images.githubusercontent.com/55429912/120593467-86b51280-c47a-11eb-97ec-06dc0179e148.png)

`이진탐색 + 연결리스트`

이진탐색: 탐색 → O(logN) / 삽입, 삭제 불가능
연결리스트: 삽입, 삭제 → O(1)/ 탐색 → O(N)

위 두가지의 장점을 합하여 만듦

- 각 노드의 자식이 2개 이하
- 크기 : 왼쪽 자식 < 부모 노드 < 오른쪽 자식노드
- 중복된 노드가 없어야함
  - 검색 목적의 자료 구조로서 중복 값이 많은 경우 굳이 트리를 사용하여 검색 속도를 느리게 할 필요 없음.

이진탐색트리의 순회는 **중위순회(inorder)** 방식(왼쪽 - 루트 - 오른쪽)

```C
void inorder(treePtr p){
  if(p) { // NULL 값이 아닌 경우
    inorder(p->leftChild);
    cout << p->data << ' ';
    inorder(p->rightChild);
  }
}
```

시간 복잡도

- 균등 트리: 노드의 개수가 N개일 때: O(logN)
- 편향 트리: 노드의 개수가 N개일 때: O(N)

`삽입, 검색, 삭제 시간복잡도는 트리의 Depth에 비례`

**삭제의 3가지 Case**

1. 자식이 없는 리프노드 → 그냥 삭제
2. 자식이 1개인 노드 → 지워진 노드에 자식을 올리기
3. 자식이 2개인 노드 → 오른쪽 자식노드에서 가장 작은 값or 왼쪽 노드에서 가장 큰 값을 올리기

---

## 해시(Hash)

![image](https://user-images.githubusercontent.com/55429912/120598732-997f1580-c481-11eb-9be5-2abd25ba606c.png)

`Key와 Value를 1:1로 연관지어 저장하는 연관 배열 자료구조`

- Key를 이용하여 Value 도출
- 해시함수를 이용하여 고유한 인덱스를 얻음
- 인덱스를 통해 빠른 검색 속도를 갖음

**구조**

- Key
  - 고유한 값
  - 저장 공간의 효율성을 위해 Hash Function에 입력하여 Hash로 변경 후 저장
- Hash Function
  - Key를 Hash로 바꿔주는 역할
  - 해시충돌이 발생할 확률을 최대한 줄이는 함수를 만드는 것이 중요
    - 해시충돌: 서로 다른 테이터가 같은 해시 값으로 충돌나는 현상
    - 해결법
      1. Separating Chaining: LinkedList 또는 RBT를 사용하여 노드를 추가하여 Value를 삽입하는 방식
      2. Open Address: 해시충돌이 발생하면, 다른 해시 버킷에 해당 자료를 삽입하는 방식
- Value
  - 저장소에 최종적으로 저장되는 값
  - Key와 매칭되어 저장, 삭제, 검색, 접근 가능

**장단점**

- 장점

  1. 적은 리소스로 많은 데이터를 효율적으로 관리 가능
  2. 배열의 인덱스를 사용하기 때문에 빠른 검색, 삽입, 삭제 가능
  3. Key와 Hash에 연관성이 없어 보안성↑

- 단점

  1. 공간 복잡도 증가
  2. 해시 함수에 의존

---

## 트라이

![image](https://user-images.githubusercontent.com/55429912/120600867-38a50c80-c484-11eb-93e8-55f53bd6bddd.png)

`문자열을 저장하고 효율적으로 탐색하기 위한 트리형태의 자료구조`

- 문자열 자동완성

**시간복잡도**

제일 긴 문자열의 길이: L
총 문자열들의 수: M

- 생성시 시간 복잡도: O(M \* L)
  - 모든 문자열들을 넣어야 하니 `M`개에 대해서 트라이 자료구조에 넣는건 가장 긴 문자열 길이 `L`만큼 걸리니 총 `O(M * L)` 만큼 걸림
- 탐색: O(L)
  - 트리를 최대 깊이 까지 들어간다 하더라도 가장 긴 문자열의 길이만큼만 탐색하면 되기 때문에 O(L)만큼 걸림

---

## 레드블랙트리(RBT, Red-Black Tree)

![image](https://user-images.githubusercontent.com/55429912/120613287-0d74ea00-c491-11eb-8df0-0a6fb437aaff.png)

`자가 균형 BST로서, 동일한 노드의 개수일 때, Depth를 최소화하여 시간 복잡도를 줄이는 트리 형식의 자료구조`

- 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 트리가 완전이진트리인 경우이다.
- 삽입, 삽제, 검색에서 최악의 경우에도 일정한 실행시간을 보장

**RBT 조건**

- 각 노드는 `Red`혹은 `Black`의 색을 갖는다.
- 루트 노드의 색깔은 `Black`이다.
- 각 리프노드의 색깔은 `Black`이다.
  - 노드의 child가 없을 경우, child를 가르키는 포인터는 NIL값을 저장하는데 이러한 NIL은 리프노드로 간주한다.
- 어떤 노드의 색깔이 `Red`라면 해당 노드의 자식 노드의 색깔은 모두 `Black`이다.
  - `Red`인 노드가 연속으로 나올 수 없다.
- 어떤 노드로부터 시작되어 리프 노드에 도달하는 모든 경로에는 리프노드를 제외하면 모두 같은 개수의 블랙노드가 있다.

**삽입**

1. BST의 특성을 유지하면서 노드를 삽입
2. 삽입된 노드의 색깔은 `Red`로 지정
   - Black-Height의 변경을 최소화하기 위해
3. RBT 조건에 부합하도록 노드 설정
   - RBT 특성위배시 Recoloring을 통해 노드 색깔 조정
   - Black-Height 위배시 Rotation을 통해 height를 조정

---

## 그래프(Graph)

`노드와 그 노드르 연결하는 간선을 하나로 모아 놓은 자료구조`

- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조이다
- 네트워크 모델
- 그래프는 순환(Cyclic)혹은 비순환(Acyclic)이다.
- 그래프는 방향 그래프와 무방향 그래프가 있다.

**구현 방법**

1. 인접 행렬(adjacent matrix)

`정방 행렬을 사용하는 방법`

공간 복잡도: O(V^2)

그래프에 **간선이 많이 존재하는 밀집그래프(Dense Graph)**에 사용

장점:

- 노드간의 연결 관계를 O(1)로 파악할 수 있음

단점:

- 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다.
- 그래프의 존재하는 모든 간선의 수를 파악하려면 O(V^2)이 걸린다
  - 인접 행렬 전체를 조사해야하기 때문

2. 인접 리스트(adjacent list)

`연결 리스트를 사용하는 방법`

공간 복잡도: O(E + V)

- 간선의 개수에 비례하는 메모리만 차지
- 그래프내에 **간선이 적은 희소 그래프(Sparse Grapg)**에 사용

장점:

- 특정 노드의 인접한 노드들을 쉽게 찾을 수 있음
- 그래프에 존재하는 모든 간선의 수를 O(V + E)안에 알수 있음

단점:

- 특정 노드간의 연결을 확인 하기 위해 O(V)만큼 탐색해야 함

**그래프와 트리의 차이**

![image](https://user-images.githubusercontent.com/55429912/120607363-12cf3600-c48b-11eb-81ea-8c67296d5d9c.png)
