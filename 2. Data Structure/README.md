# Data Structure

## 배열(Array)

- 논리적 저장순서와 물리적 저장순서가 일치
- 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다.
  - 즉, Random Access가 가능하다.
- 데이터 삽입, 삭제시 처리후 전체적으로 Shift해줘야 하기 때문에 O(N)의 시간 복잡도를 갖는다.

---

## 링크드리스트(LinkedList)

![image](https://user-images.githubusercontent.com/55429912/120528055-fb099a80-c415-11eb-8795-07c1ef2c2075.png)

`연속적이지 않은 메모리 위치에 저장되는 선형 데이터 구조`

- 논리적 저장 순서와 물리적 저장 순서가 다름
  - 데이터를 검색 시 처음 노드부터 순회해야함(O(N)의 시간 복잡도)
- 메모리 공간 상에서 각 노드들이 연속적으로 이루어져있지 않고, 각각의 노드가 다음 노드의 위치를 알고 있는 형태
- 원소를 삽입/ 삭제 시 그 원소를 찾기 위해 O(N)의 시간이 발생하고, 추가적으로 데이터를 삽입/ 삭제하는 경우 O(1)의 시간이 걸려 완료하는데 총 O(N)의 시간이 걸립니다.
  - 즉, 만약 삽입/ 삭제하려는 데이터의 위치가 맨 앞이라면 O(1)의 시간 복잡도를 가짐

### 배열 VS 링크드 리스트

|  자료구조  | 접근 |          삽입           |          삭제           |
| :--------: | :--: | :---------------------: | :---------------------: |
|   Array    | O(1) | O(N)/ 맨 뒤일 경우 O(1) | O(N)/ 맨 뒤일 경우 O(1) |
| LinkedList | O(N) | O(N)/ 맨 앞일 경우 O(1) | O(N)/ 맨 앞일 경우 O(1) |

**메모리 할당**

- Array
  - 정적 메모리
  - Array 선언되자 마자 Complie time에 할당
- LinkedList
  - 동적 메모리
  - 새로운 Node가 추가될 때 run time에 할당

```
데이터 접근, 탐색이 중요 ⇒ 배열
데이터 추가, 삭제가 중요 ⇒ 링크드리스트
```

---

## 스택(Stack)

`LIFO(Last In First Out)의 선형 자료구조`

- 콜스택, 문자열 역순 출력 등에 사용
  - 콜스택: 컴퓨터 프로그램에서 현재 실행 중인 서브루틴에 관한 정보를 저장하는 스택 자료구조

---

## 큐(Queue)

`FIFO(First In First Out)의 선형 자료구조`

- 너비우선탐색, OS의 Ready 큐 등에 사용

---

## 트리(Tree)

![image](https://user-images.githubusercontent.com/55429912/120596118-4eafce80-c47e-11eb-9f0c-5bc33705f0d0.png)

`계층적 관계를 표현하는 비선형 자료구조`

- 사이클이 없는 그래프의 한 종류
  - Directed Acyclic Graph: 방향성이 있는 비순환 그래프
- 노드와 간선으로 구성됨
  - 노드: N개
  - 간선: N- 1개
- 임의의 두 노드간의 경로는 유일하다.

---

## 힙(Heap)

![image](https://user-images.githubusercontent.com/55429912/120530590-aa477100-c418-11eb-9da6-d12bcd873b58.png)

`완전 이진 트리의 일종으로 여러 값중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조`

검색(최대값or최솟값): O(1)
삽입: O(logN)
삭제: O(logN)

**힙 트리는 중복된 값 허용(이진 탐색 트리는 중복 값 허용 X)**

- 배열을 기반으로 한 완전 이진 트리(Complete Binary Tree)
  - 왼쪽 자식 노드: 현재 노드 \* 2
  - 오른쪽 자식 노드: 현재노드 \* 2 + 1
  - Index를 통한 Random Access 가능
- 힙의 종류로는 최대 힙과 최소 힙이 존재
  - 최대 힙: 부모 노드의 키 값 >= 자식 노드의 키 값
  - 최소 힙: 부모 노드의 키 값 <= 자식 노드의 키 값
  - 최대 최소 값을 찾는데 O(1)의 시간 소요 ⇒ Root Node의 값이 최대or 최소 이기 때문

**구현**

삽입:

1. 새로운 요소가 들어오면 힙의 마지막 노드에 삽입
2. 새로운 노드를 부모 노드와 비교하여 교환

삭제:

1. 최대/최소 값은 루트 노드이므로 루트 노드가 삭제
2. 마지막 노드의 값을 루트에 대입
3. 힙을 재구성

---

## 이진 탐색 트리(BST, Binary Search Tree)

![image](https://user-images.githubusercontent.com/55429912/120593467-86b51280-c47a-11eb-97ec-06dc0179e148.png)

`이진탐색 + 연결리스트`

이진탐색: 탐색 → O(logN) / 삽입, 삭제 불가능
연결리스트: 삽입, 삭제 → O(1)/ 탐색 → O(N)

위 두가지의 장점을 합하여 만듦

- 각 노드의 자식이 2개 이하
- 크기 : 왼쪽 자식 < 부모 노드 < 오른쪽 자식노드
- 중복된 노드가 없어야함
  - 검색 목적의 자료 구조로서 중복 값이 많은 경우 굳이 트리를 사용하여 검색 속도를 느리게 할 필요 없음.

이진탐색트리의 순회는 **중위순회(inorder)** 방식(왼쪽 - 루트 - 오른쪽)

```C
void inorder(treePtr p){
  if(p) { // NULL 값이 아닌 경우
    inorder(p->leftChild);
    cout << p->data << ' ';
    inorder(p->rightChild);
  }
}
```

시간 복잡도

- 균등 트리: 노드의 개수가 N개일 때: O(logN)
- 편향 트리: 노드의 개수가 N개일 때: O(N)

`삽입, 검색, 삭제 시간복잡도는 트리의 Depth에 비례`

**삭제의 3가지 Case**

1. 자식이 없는 리프노드 → 그냥 삭제
2. 자식이 1개인 노드 → 지워진 노드에 자식을 올리기
3. 자식이 2개인 노드 → 오른쪽 자식노드에서 가장 작은 값or 왼쪽 노드에서 가장 큰 값을 올리기

---

## 해시테이블(Hash Table)

![image](https://user-images.githubusercontent.com/55429912/120598732-997f1580-c481-11eb-9be5-2abd25ba606c.png)

`Key와 Value로 연관지어 저장하는 연관 배열 자료구조`

- Key를 이용하여 Value 도출
- 내부적으로 배열(버킷)을 사용하여 데이터를 저장
- 해시함수를 이용하여 배열의 고유한 인덱스를 생성
- 인덱스를 통해 빠른 검색 속도를 갖음

**구조**

- Key

  - 고유한 값
  - 저장 공간의 효율성을 위해 Hash Function에 입력하여 Hash로 변경 후 저장

- Hash Function

  - Key를 Hash로 바꿔주는 역할
  - 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수
  - 해시충돌이 발생할 확률을 최대한 줄이는 함수를 만드는 것이 중요

- Value
  - 저장소에 최종적으로 저장되는 값
  - Key와 매칭되어 저장, 삭제, 검색, 접근 가능

**클러스터**

`해시 함수를 통해 얻은 해시 값들이 저장공간 한 쪽에 뭉치게 되는 경우`

- 해시충돌: 서로 다른 테이터가 같은 해시 값으로 충돌나는 현상

  - 해결법

    1. 분리 연결법(Separating Chaining): 자료구조(LinkedList, RBT)를 활용해 추가 메모리를 사용하여 다음 데이터의 주소를 저장하는 것

    ![image](https://user-images.githubusercontent.com/55429912/121355076-7addba80-c96a-11eb-8b8d-e78c3b90bb24.png)

    - 간단하게 구현이 가능하며, 손쉽게 삭제 가능
    - 데이터의 수가 많아지면 메모리가 증가하여 캐시의 효율성 감소

    2. 개방 주소법(Open Addressing): 해시충돌이 발생하면, 다른 비어있는 해시 버킷에 해당 자료를 삽입하는 방식

    ![image](https://user-images.githubusercontent.com/55429912/121355265-ab255900-c96a-11eb-8367-caff6b81f766.png)

    - 선형 탐사(Linear Probing): 현재 버킷의 index로부터 고정폭 만큼씩 이동하여 차례대로 검색해 비어있는 버킷에 데이터 저장
    - 제곱 탐사(Quadratic Probing): 해시의 저장순서 폭을 제곱으로 저장하는 방식(1 → 4 → 9 ... )
    - 이중 해싱(Double Hashing Probing): 해시된 값을 한번 더 해싱하여 해시의 규칙성을 없애버리는 방식
      - 1차 해시 함수 ⇒ key의 해시 값을 얻기 위해 사용 
        - ex) h1(k) = k % 17
      - 2차 해시 함수 ⇒ 해시 충돌이 발생했을 경우 탐사 이동 폭을 얻기 위해 사용
        - ex) h2(k) = (k % c) + 1

<br>

**해시테이블 삭제**

![image](https://user-images.githubusercontent.com/55429912/121356871-3e12c300-c96c-11eb-8b6d-26c98ca031e5.png)

```
삭제처리 중요성
해시함수가 % 7 일경우
처음에 2가 들어감 ⇒ 2
두번째 9가 들어감 ⇒ 2
기존의 2가 삭제됨 ⇒ 인덱스 2는 DELETED
9검색  ⇒ 인덱스 2 비어있음 ⇒ 데이터가 존재하지 않는다고 판단
다음 Index까지 검색을 연결해 줄수 있도록 더미 노드를 삽입
더미 노드가 많아지게 되면 새로운 array를 만들어서 Hash를 리빌딩하여 성능을 유지
```




**해쉬테이블의 성능 향상 방법?**

캐시 로직을 추가하여 자주 hit하는 데이터에 데에서 바로 데이터를 찾게 해주어 성능을 향상 시킬 수 있음!

### 해시테이블 장단점

- 장점
  - 해싱된 키를 가지고 배열의 인덱스로 사용하기 때문에 빠른 검색, 삽입, 삭제 가능
- 단점
  - 공간 효율성이 떨어짐
    - 데이터가 저장되기 전에 미리 저장공간을 확보해 놓아야 한다.
  - 해시 함수의 의존도가 높음

---

## 트라이

![image](https://user-images.githubusercontent.com/55429912/120600867-38a50c80-c484-11eb-93e8-55f53bd6bddd.png)

`문자열을 저장하고 효율적으로 탐색하기 위한 트리형태의 자료구조`

- 문자열 자동완성

**시간복잡도**

제일 긴 문자열의 길이: L
총 문자열들의 수: M

- 생성시 시간 복잡도: O(M \* L)
  - 모든 문자열들을 넣어야 하니 `M`개에 대해서 트라이 자료구조에 넣는건 가장 긴 문자열 길이 `L`만큼 걸리니 총 `O(M * L)` 만큼 걸림
- 탐색: O(L)
  - 트리를 최대 깊이 까지 들어간다 하더라도 가장 긴 문자열의 길이만큼만 탐색하면 되기 때문에 O(L)만큼 걸림

---

## 레드블랙트리(RBT, Red-Black Tree)

![image](https://user-images.githubusercontent.com/55429912/120613287-0d74ea00-c491-11eb-8df0-0a6fb437aaff.png)

`자가 균형 BST로서, 동일한 노드의 개수일 때, Depth를 최소화하여 시간 복잡도를 줄이는 트리 형식의 자료구조`

- 동일한 노드의 개수일 때, depth가 최소가 되는 경우는 트리가 완전이진트리인 경우이다.
- 삽입, 삽제, 검색에서 최악의 경우에도 일정한 실행시간을 보장

**RBT 조건**

- 각 노드는 `Red`혹은 `Black`의 색을 갖는다.
- 루트 노드의 색깔은 `Black`이다.
- 각 리프노드의 색깔은 `Black`이다.
  - 노드의 child가 없을 경우, child를 가르키는 포인터는 NIL값을 저장하는데 이러한 NIL은 리프노드로 간주한다.
- 어떤 노드의 색깔이 `Red`라면 해당 노드의 자식 노드의 색깔은 모두 `Black`이다.
  - `Red`인 노드가 연속으로 나올 수 없다.
- 어떤 노드로부터 시작되어 리프 노드에 도달하는 모든 경로에는 리프노드를 제외하면 모두 같은 개수의 블랙노드가 있다.

**삽입**

1. BST의 특성을 유지하면서 노드를 삽입
2. 삽입된 노드의 색깔은 `Red`로 지정
   - Black-Height의 변경을 최소화하기 위해
3. RBT 조건에 부합하도록 노드 설정
   
   ![image](https://user-images.githubusercontent.com/55429912/121356383-bdec5d80-c96b-11eb-9462-c8bea12d4fc0.png)

   - RBT 특성위배시 Recoloring을 통해 노드 색깔 조정
   - Black-Height 위배시 Rotation을 통해 height를 조정

---

## 그래프(Graph)

`노드와 그 노드르 연결하는 간선을 하나로 모아 놓은 자료구조`

- 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조이다
- 네트워크 모델
- 그래프는 순환(Cyclic)혹은 비순환(Acyclic)이다.
- 그래프는 방향 그래프와 무방향 그래프가 있다.

**구현 방법**

1. 인접 행렬(adjacent matrix)

`정방 행렬을 사용하는 방법`

공간 복잡도: O(V^2)

그래프에 간선이 많이 존재하는 밀집그래프(Dense Graph)에 사용

장점:

- 노드간의 연결 관계를 O(1)로 파악할 수 있음

단점:

- 어떤 노드에 인접한 노드들을 찾기 위해서는 모든 노드를 전부 순회해야 한다.
- 그래프의 존재하는 모든 간선의 수를 파악하려면 O(V^2)이 걸린다
  - 인접 행렬 전체를 조사해야하기 때문

2. 인접 리스트(adjacent list)

`연결 리스트를 사용하는 방법`

공간 복잡도: O(E + V)

- 간선의 개수에 비례하는 메모리만 차지
- 그래프내에 간선이 적은 희소 그래프(Sparse Grapg)에 사용

장점:

- 특정 노드의 인접한 노드들을 쉽게 찾을 수 있음
- 그래프에 존재하는 모든 간선의 수를 O(V + E)안에 알수 있음

단점:

- 특정 노드간의 연결을 확인 하기 위해 O(V)만큼 탐색해야 함

**그래프와 트리의 차이**

![image](https://user-images.githubusercontent.com/55429912/121016900-aaa88900-c7d7-11eb-97ae-1cb30aeddd29.png)
